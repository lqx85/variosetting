<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>小白白高度表</title>
  <link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
  <header>
    <h1>小白白高度表</h1>
  </header>
  <div class="topnav">
    <a href="index.html">简要介绍</a>
    <a href="normal_setting.html">参数设置</a>
    <a href="advance_setting.html">高级设置</a>
    <a href="hardware_upgade.html" class="active">更新固件</a>
  </div>
  <div class="content">
    <div class="card-grid">
      <div class="card">
        <p>
          <button id="connectBleButton" class="connectButton"> 打开小白白的链接</button>
          <span style="padding-left: 50px;"></span>
          <button id="disconnectBleButton" class="disconnectButton"> 断开小白白的链接</button>
        </p>
        <p class="gray-label">链接状态: <strong><span id="bleState" style="color:#d13a30;">未链接</span></strong>
        </p>
      </div>
    </div>
    <div class="card-grid">
      <div class="card">
        <h2>固件升级</h2>
        <p class="p_left">
          <input type="file" name="otafile" id="otafile" />
          <span style="padding-left: 200px;"></span>
          <button id="upload" accept=".bin" onclick="startUpload()">更新</button>

        <div id="progressBar">0%</div>

        </p>
      </div>
    </div>

    <div class="card-grid">
      <div class="card">
        <h2>接收数据</h2>
        <div id="log" class="black-bg"></div>
      </div>
    </div>
  </div>
  <script src="app.js"></script>
  <script>
    var progress_present = 0;
    const inputfile = document.getElementById("otafile");
    const progressBar = document.getElementById("progressBar");
    const uploadBtn = document.getElementById("upload");

    class FileStreamer {
      constructor(file, encoding = 'utf-8') {
        this.file = file;
        this.offset = 0;
        this.defaultChunkSize = 16; // bytes
        this.textDecoder = new TextDecoder(encoding);
        this.rewind();
      }
      rewind() {
        this.offset = 0;
      }
      isEndOfFile() {
        return this.offset >= this.getFileSize();
      }
      async eventPromise(target, eventName) {
        return new Promise((resolve) => {
          const handleEvent = (event) => {
            resolve(event);
          };
          target.addEventListener(eventName, handleEvent);
        });
      }
      async readFile(blob) {
        const fileReader = new FileReader();
        fileReader.readAsArrayBuffer(blob);
        const event = await this.eventPromise(fileReader, 'loadend');
        const target = event.target;
        if (target.error) {
          throw target.error;
        }
        return target.result;
      }
      async readBlockAsText(length = this.defaultChunkSize) {
        const blob = this.file.slice(this.offset, this.offset + length);
        const buffer = await this.readFile(blob);
        const decodedText = this.textDecoder.decode(buffer, { stream: true });
        this.offset += blob.size;
        progress_present = this.offset / this.file.size * 100;

        if (this.isEndOfFile()) {
          const finalText = this.textDecoder.decode();
          if (finalText) {
            return decodedText + finalText;
          }
        }
        return decodedText;
      }
      getFileSize() {
        return this.file.size;
      }
    }

    async function startUpload() {
      if (inputfile.files.length == 0) {
        alert("No file selected!");
      }
      else {
        const fileStreamer = new FileStreamer(inputfile.files[0]);
        await sendMessage("#HWBG\n");
        while (!fileStreamer.isEndOfFile()) {
          const data = await fileStreamer.readBlockAsText();
          // console.log(progress_present.toFixed(1), '%');
          console.log(data);
          await sendMessage("#HWDA"+data+"\n");
        }
        await sendMessage("#HWFN\n");
      }
    }
//https://github.com/electron/electron/issues/40282
    setInterval( () => {
      progressBar.style.width = progress_present.toFixed(1) + "%";
      progressBar.innerHTML = progress_present.toFixed(1) + "%";
    }, 200);//Call () every second
  </script>
</body>

</html>